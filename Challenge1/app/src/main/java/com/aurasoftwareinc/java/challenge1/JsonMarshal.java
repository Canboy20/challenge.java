package com.aurasoftwareinc.java.challenge1;

import android.util.Log;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;

public class JsonMarshal
{
    public static JSONObject marshalJSON(Object object)
    {


        JSONObject parentJSON = new JSONObject();   //This JSON will only be needed if current object being marshalled is 'SubclassTypes'
        JSONObject objectJSON = new JSONObject();   //This JSON will be used to place the objects variables and their values


        try
        {


            //Gets class of object
            Class myObjectClass = object.getClass();


            //We get all the available fields inside the object being analyzed. There is a chance a field might be private so we enable accessibility to those to continue
            for (Field field : myObjectClass.getDeclaredFields()) {


                //Before proceeding, lets check whether the variables are private or not. (Ex: objectTypes is private)
                //If so, we must make them Accessible first in order to read the data they contain
                if(Modifier.isPrivate(field.getModifiers())) {
                    field.setAccessible(true);
                }



                //***This is IMPORTANT***
                //  !isSynthetic() issue : Android Instant run implements an interface name "runtime.IncrementalChange". When we call 'getDeclaredFields',  a weird field name "$change"
                //                         shows itself out of nowhere, which happens to come from Android Instant run.
                //                         To skip this field, we implement !isSynthetic(), which will ignore any fields generated by Android Instant run, in this case "$change"
                // serialVersionUID issue: There is also another issue of receiving a field name 'serialVersionUID', which can be easily ignored with 'equals()'

                if (!field.getName().equals("serialVersionUID") &&  !field.isSynthetic()) {



                    //***TRAVERSE RULES***
                    //While looking at each field, there can be 2 Cases.
                    //CASE 1: If the current field is a primitive, then we can directly put the value tothe JSON without any further checks(We still have to check if variable is null or not)
                    //CASE 2: If field is not a primitive type, then more work is needed to retrieve the value since the field can be an Object, an Array , an Object that implements JSONMarshallInterface contract

                    if(field.getType().isPrimitive()){

                        //Check if value is null. If so add value as JSONObject.NULL
                        if(field.get(object) == null){

                            objectJSON.put(field.getName(), JSONObject.NULL);

                        }else{

                            objectJSON.put(field.getName(), field.get((object)));

                        }


                    }else{


                        Class<?> reference  =   field.getType();
                        //Since the local variables of Object are empty(null), we must create an instance of each variable in order to proceed


                        //***RULE For non primitive fields****
                        //We first check whether current field is an instance of JsonMarshallInterface(Whether field class implements JsonMarshallInterface contract)
                        //CASE 1: If it does, it means current object implements JsonMarshallInterface contract, meaning it can be marshalled further by calling 'marhshallJSON()' function
                        //CASE 2: If it isnt, then it means field cant be marshalled further
                        if(JsonMarshalInterface.class.isAssignableFrom(reference)){


                            //Because this field implements the JsonMarshallInterface, we will retrieve the value of this JSON by calling the marhshallJSON() function of the field
                            Method marshalJSONMethod = reference.getDeclaredMethod("marshalJSON");
                            objectJSON.put(field.getName(), marshalJSONMethod.invoke(field.get(object)));


                        }else{



                            //***RULE For object that dont implement JsonMarshallInterface****
                            //We start by checking whether object is of type JSONObject.class or JSONArray.class. If it is, we easily added to the JSON
                            //If not, then we check whether object is an array or a plain object. If its an array, we perform an array traverse

                            if(field.getType() == JSONObject.class){

                                objectJSON.put(field.getName(), field.get(object));


                            }else if(field.getType() == JSONArray.class){


                                objectJSON.put(field.getName(), field.get(object));



                            }else{


                                //We check whether current field is an Array or just a plain Object
                                if(field.getType().isArray()){


                                    if(field.get(object) == null){

                                        objectJSON.put(field.getName(),JSONObject.NULL);


                                    }else{



                                        JSONArray jsonArray = new JSONArray();
                                        Object arrayObject = field.get(object);

                                        int length = Array.getLength(arrayObject);
                                        for (int i = 0; i < length; i ++) {
                                            Object arrayElement = Array.get(arrayObject, i);
                                            jsonArray.put(arrayElement);
                                        }

                                        objectJSON.put(field.getName(),jsonArray);
                                    }

                                }else{


                                    //Check if value of object is null. If it is, set value of JSON to JSONObject.NULL
                                    if(field.get(object)==null){
                                        objectJSON.put(field.getName(), JSONObject.NULL);

                                    }else{
                                        objectJSON.put(field.getName(), field.get(object));

                                    }


                                }



                            }


                        }


                    }


                }


            }



            //Once object JSON has been created, we can finally return it to the method that called this long method. myObjectClass.getSimpleName() returns the name of the Class which is currently being marshalled
            //If this class is "SubclassTypes", then we first place it in a parentJSON and then return it
            if(myObjectClass.getSimpleName().equals("SubclassTypes")){

                //At last, we get our marshalledJSON. Finally :)

                return parentJSON.put(myObjectClass.getSimpleName(), objectJSON );

            }else{

                //Job is done for this method
                return objectJSON;
            }


            //Just some catches...
        }catch (NoSuchMethodException e) {
            e.printStackTrace();
            System.out.print("");

        }catch (Exception ignore) {

            System.out.print("");
        }




        return null;

    }








    public static boolean unmarshalJSON(Object object, JSONObject json)
    {



        //Get class of object
        Class myObjectClass = object.getClass();
        String nameOfClass = myObjectClass.getSimpleName();



        try {


            for (Field field : myObjectClass.getDeclaredFields()) {


                //Before proceeding, lets check whether the variables are private or not. (Ex: 'objectTypes' variable in 'SubclassTypes class' is private)
                //If so, we must make them Accessible first in order to read the data they contain
                if(Modifier.isPrivate(field.getModifiers())) {
                    field.setAccessible(true);
                }



                //***This is IMPORTANT***
                //  !isSynthetic() issue : Android Instant run implements an interface name "runtime.IncrementalChange". When we call 'getDeclaredFields',  a weird field name "$change"
                //                         shows itself out of nowhere, which happens to come from Android Instant run.
                //                         To skip this field, we implement !isSynthetic(), which will ignore any fields generated by Android Instant run, in this case "$change"
                //
                // serialVersionUID issue: There is also another issue of receiving a field name 'serialVersionUID', which can be easily ignored with 'equals()'
                if (!field.getName().equals("serialVersionUID") &&  !field.isSynthetic()) {






                    //***TRAVERSE RULES***
                    //While looking at each field, we check for one of the 2 cases below.
                    //CASE 1: If the current field is a primitive, then we can directly get the value from JSON without any further checks(We still have to check if value is JSON is null or not)
                    //CASE 2: If field is not a primitive type, then more work is needed to set its value. Field can be an Object, an Array , an Object that implements JSONMarshallInterface contract

                    if(field.getType().isPrimitive()){

                        field.setAccessible(true);

                        //For primitives, we can set the value directly. But lets not forget the null check :)
                        if(json.get(field.getName()) == JSONObject.NULL){
                            field.set(object, null);

                        }else{
                            field.set(object, json.get(field.getName()));

                        }



                    }else{




                        //***Rule for non primitive fields***
                        //We must check whether obj is an Instance of JsonMarshallInterface.
                        //CASE 1: If it is, it means current object implements JsonMarshallInterface contract, meaning it can be unmarshalled even further by calling unmarshallJSON method
                        //CASE 2: If it isnt, then it means we reached end of unmarshmall for current object

                        //***General Rule Here***
                        //Since the local variables of Object are empty(null) at start, we must create an instance of each variable in order to proceed


                        //Gets Class of field type
                        Class<?> reference  =   field.getType();


                        //CASE 1
                        if(JsonMarshalInterface.class.isAssignableFrom(reference)){


                            Object obj =reference.newInstance();

                            JSONObject jsonObject =  json.getJSONObject(nameOfClass);
                            JSONObject jsonTypesResponseData = jsonObject.getJSONObject(field.getName());



                            //The value of the variable is null initially. We set a value to the variable by setting our previously created object to it
                            field.set(object, obj);

                            //Holds reference of unmarshallJSON method which will be called next
                            Method unmarshalJSONMethod = reference.getDeclaredMethod("unmarshalJSON",  JSONObject.class);

                            // invokes the method at runtime
                            unmarshalJSONMethod.invoke(obj, jsonTypesResponseData);






                            //CASE 2
                        }else{



                            //If the field is an array, then we need to traverse the array and add each value individually
                            //Otherwise we can set the value directly
                            if(field.getType().isArray()){

                                if(json.isNull( field.getName()) ){
                                    field.set(object, null);

                                }else{

                                    int lengthOfArray= json.getJSONArray(field.getName()).length();

                                    // First, create the array
                                    Object myArray = Array.newInstance(field.getType().getComponentType(), lengthOfArray);

                                    // Then, adding value to that array
                                    for (int i = 0; i < lengthOfArray; i++) {

                                        Array.set(myArray, i, json.getJSONArray(field.getName()).get(i));
                                    }


                                    // Finally, set value for that array field
                                    field.set(object, myArray);

                                }



                            }else{

                                //The value of the variable is null initially. We set a value to the variable by setting our previously created object to it
                                if(json.isNull( field.getName()) ){
                                    field.set(object, null);

                                }else{
                                    field.set(object, json.get(field.getName()) );

                                }



                            }



                        }


                    }


                }



            }


        } catch (JSONException | IllegalAccessException | InstantiationException | NoSuchMethodException | InvocationTargetException e) {

            e.printStackTrace();

        }


        return true;


    }
}